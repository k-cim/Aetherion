// === File: Features/Settings/ThemeDefautlView.swift
// Description: Paramètres — Thèmes (roue basée sur JSON), Annuler/Appliquer.
// NOTE: Stacks & paddings conservés à l’identique.

import SwiftUI
import UIKit

// -------- Enum UNIQUE pour les libellés "fallback" (utile si liste JSON vide)
private enum ThemeChoice: CaseIterable, Identifiable {
    case dark, light, blue, sepia, emerald
    var id: Self { self }
    var label: String {
        switch self {
        case .dark:    return "Thème Foncé"
        case .light:   return "Thème Clair"
        case .blue:    return "Thème Bleu"
        case .sepia:   return "Thème Sépia"
        case .emerald: return "Thème Émeraude"
        }
    }
}

// -------- Persisted snapshot (sauvegarde/restaure)
private struct PersistedThemeState {
    var background: Color
    var foreground: Color
    var secondary: Color
    var accent: Color
    var controlTint: Color
    var cardStartOpacity: Double
    var cardEndOpacity: Double
    var cardStartColor: Color
    var cardEndColor: Color
    var headerColor: Color

    static func loadFromDisk(using p: ThemePersistence = .shared, base: Theme) -> PersistedThemeState {
        PersistedThemeState(
            background:      p.loadBackgroundColor(default: base.background),
            foreground:      p.loadPrimaryTextColor(default: base.foreground),
            secondary:       p.loadSecondaryTextColor(default: base.secondary),
            accent:          p.loadIconColor(default: base.accent),
            controlTint:     p.loadControlTint(default: base.controlTint),
            cardStartOpacity:p.loadCardGradient(defaultStart: base.cardStartOpacity, defaultEnd: base.cardEndOpacity).0,
            cardEndOpacity:  p.loadCardGradient(defaultStart: base.cardStartOpacity, defaultEnd: base.cardEndOpacity).1,
            cardStartColor:  p.loadCardGradientColors(defaultStart: base.cardStartColor,  defaultEnd: base.cardEndColor).0,
            cardEndColor:    p.loadCardGradientColors(defaultStart: base.cardStartColor,  defaultEnd: base.cardEndColor).1,
            headerColor:     p.loadHeaderColor(default: base.headerColor)
        )
    }

    func saveToDisk(using p: ThemePersistence = .shared) {
        p.saveBackgroundColor(background)
        p.savePrimaryTextColor(foreground)
        p.saveSecondaryTextColor(secondary)
        p.saveIconColor(accent)
        p.saveControlTint(controlTint)
        p.saveCardGradient(start: cardStartOpacity, end: cardEndOpacity)
        p.saveCardGradientColors(start: cardStartColor, end: cardEndColor)
        p.saveHeaderColor(headerColor)
    }
}

// -------- Mapping fallback (si JSON absent)
private func themeID(for choice: ThemeChoice) -> ThemeID {
    switch choice {
    case .dark:    return .aetherionDark
    case .light:   return .aetherionLight
    case .blue:    return .aetherionBlue
    case .sepia:   return .aetherionSepia
    case .emerald: return .aetherionEmerald
    }
}
private func choice(for id: ThemeID) -> ThemeChoice {
    switch id {
    case .aetherionDark:    return .dark
    case .aetherionLight:   return .light
    case .aetherionBlue:    return .blue
    case .aetherionSepia:   return .sepia
    case .aetherionEmerald: return .emerald
    }
}

// -------- Snapshot visuel local pour les cartes
private struct LocalTheme {
    let background: Color
    let foreground: Color
    let secondary: Color
    let accent: Color
    let controlTint: Color
    let cardStartOpacity: Double
    let cardEndOpacity: Double
    let cardStartColor: Color
    let cardEndColor: Color
    let cornerRadius: CGFloat
    let headerColor: Color

    static func fromTheme(_ t: Theme) -> LocalTheme {
        LocalTheme(
            background: t.background,
            foreground: t.foreground,
            secondary: t.secondary,
            accent: t.accent,
            controlTint: t.controlTint,
            cardStartOpacity: t.cardStartOpacity,
            cardEndOpacity: t.cardEndOpacity,
            cardStartColor: t.cardStartColor,
            cardEndColor: t.cardEndColor,
            cornerRadius: t.cornerRadius,
            headerColor: t.headerColor
        )
    }

    static func load() -> LocalTheme {
        let p = ThemePersistence.shared
        let base = Theme.preset(.aetherionDark)
        return LocalTheme(
            background: p.loadBackgroundColor(default: .black),
            foreground: p.loadPrimaryTextColor(default: base.foreground),
            secondary: p.loadSecondaryTextColor(default: base.secondary),
            accent: p.loadIconColor(default: base.accent),
            controlTint: p.loadControlTint(default: base.controlTint),
            cardStartOpacity: p.loadCardGradient(defaultStart: base.cardStartOpacity, defaultEnd: base.cardEndOpacity).0,
            cardEndOpacity:   p.loadCardGradient(defaultStart: base.cardStartOpacity, defaultEnd: base.cardEndOpacity).1,
            cardStartColor:   p.loadCardGradientColors(defaultStart: base.cardStartColor, defaultEnd: base.cardEndColor).0,
            cardEndColor:     p.loadCardGradientColors(defaultStart: base.cardStartColor, defaultEnd: base.cardEndColor).1,
            cornerRadius: base.cornerRadius,
            headerColor: p.loadHeaderColor(default: base.headerColor)
        )
    }
}

// -------- Radio (petit rond)
private struct RadioDot: View {
    @EnvironmentObject private var themeManager: ThemeManager
    @Binding var isOn: Bool
    var body: some View {
        Button {
            isOn.toggle()
        } label: {
            Image(systemName: isOn ? "largecircle.fill.circle" : "circle")
                .font(.title3)
                .foregroundStyle(themeManager.theme.accent)
        }
        .buttonStyle(.plain)
        .contentShape(Rectangle())
    }
}

// -------- Carte locale (même look que tes autres cartes)
private struct LocalCard<Content: View>: View {
    let theme: LocalTheme
    let fixedHeight: CGFloat?
    @ViewBuilder var content: () -> Content

    init(theme: LocalTheme, fixedHeight: CGFloat? = nil, @ViewBuilder content: @escaping () -> Content) {
        self.theme = theme
        self.fixedHeight = fixedHeight
        self.content = content
    }

    var body: some View {
        let start = theme.cardStartColor.opacity(theme.cardStartOpacity)
        let end   = theme.cardEndColor.opacity(theme.cardEndOpacity)

        ZStack {
            RoundedRectangle(cornerRadius: theme.cornerRadius, style: .continuous)
                .fill(LinearGradient(colors: [start, end], startPoint: .leading, endPoint: .trailing))
                .overlay(
                    RoundedRectangle(cornerRadius: theme.cornerRadius, style: .continuous)
                        .strokeBorder(Color.white.opacity(0.08))
                )
            content()
                .padding(.horizontal, 12)
                .padding(.vertical, 10)
        }
        .frame(maxWidth: .infinity)
        .frame(height: fixedHeight)
    }
}

// =====================================================
//                    VIEW PRINCIPALE
// =====================================================
struct ThemeDefautlView: View {
    // Thème visuel local à l’écran
    @State private var theme = LocalTheme.load()

    // Snapshots pour Annuler / Retour
    @State private var initialThemeID: ThemeID = .aetherionDark
    @State private var initialSnapshot: Theme? = nil                 // thème complet à l’arrivée
    @State private var initialPersisted: PersistedThemeState? = nil  // ce qui est sur disque à l’arrivée
    @State private var didApply: Bool = false                        // passé à true après “Appliquer”

    // Intéractions locales
    @State private var showVisualisation: Bool = false

    // Données pour la roue basée JSON
    @State private var themeItems: [ThemeListItem] = []              // items découverts
    @State private var selectedItem: ThemeListItem? = nil            // nil = “Actuel (ne rien changer)”

    // Accès au ThemeManager global
    @EnvironmentObject private var themeManager: ThemeManager
    @Environment(\.dismiss) private var dismiss
    // — États locaux —

    // fallback (libellé pour les textes si JSON vide)
    @State private var selectedChoice: ThemeChoice = .dark

    // libellé utilisé dans tes textes sous les cartes (si JSON → displayName, sinon fallback enum)
    private var selectedLabel: String {
        selectedItem?.displayName ?? selectedChoice.label
    }
    // type de source (app vs enregistré)
    private var isPresetFromBundle: Bool {
        guard let url = selectedItem?.fileURL else { return true }
        return !url.path.contains("/Documents/")
    }


    /// Mémorise l’état courant au moment d’entrer dans l’écran
    private func takeSnapshotOnAppear() {
        let current = themeManager.theme
        initialThemeID   = current.id
        initialSnapshot  = current
        initialPersisted = PersistedThemeState.loadFromDisk(base: current)
        // aligne l’aperçu local
        theme = LocalTheme.fromTheme(current)
    }

    /// Applique un Theme comme aperçu global + aligne le pavé local (sans marquer “appliqué”)
    private func previewTheme(_ t: Theme) {
        withAnimation(.easeInOut) {
            themeManager.theme = t
            themeManager.updateBackgroundColor(t.background)
            themeManager.updateHeaderColor(t.headerColor)
            themeManager.updatePrimaryTextColor(t.foreground)
            theme = LocalTheme.fromTheme(t)
            didApply = false
        }
    }

    /// Restaure exactement l’état d’arrivée (thème + persistance)
    private func restoreSnapshot() {
        guard let snap = initialSnapshot else { return }
        // restaure la persistance telle qu’elle était à l’arrivée
        initialPersisted?.saveToDisk()
        previewTheme(snap)
        didApply = false
    }

    /// Fige l’état actuel comme “nouveau” (sauve sur disque + met à jour baseline)
    private func applyAction() {
        let t = themeManager.theme
        let p = ThemePersistence.shared
        // sauve tout
        p.saveBackgroundColor(t.background)
        p.savePrimaryTextColor(t.foreground)
        p.saveSecondaryTextColor(t.secondary)
        p.saveIconColor(t.accent)
        p.saveControlTint(t.controlTint)
        p.saveCardGradient(start: t.cardStartOpacity, end: t.cardEndOpacity)
        p.saveCardGradientColors(start: t.cardStartColor, end: t.cardEndColor)
        p.saveHeaderColor(t.headerColor)

        // nouvelle baseline
        initialThemeID   = t.id
        initialSnapshot  = t
        initialPersisted = PersistedThemeState.loadFromDisk(base: t)
        didApply = true
    }
    // Applique le theme (depuis JSON ou fallback preset) + aligne l’aperçu local
    private func applySelectedItem(_ item: ThemeListItem) {
        let t = ThemeCatalog.shared.loadTheme(from: item)
        withAnimation(.easeInOut) {
            themeManager.theme = t
            themeManager.updateBackgroundColor(t.background)
            themeManager.updateHeaderColor(t.headerColor)
            themeManager.updatePrimaryTextColor(t.foreground)
            theme = LocalTheme.fromTheme(t)   // si tu affiches un aperçu local
            didApply = false
        }
    }

    var body: some View {
        ZStack {
            theme.background.ignoresSafeArea()

            VStack(spacing: 0) {
                // ====== Titre (inchangé) ======
                HStack {
                    Text("Thème Enregistré")
                        .font(.system(size: 28, weight: .bold, design: .rounded))
                        .foregroundStyle(theme.headerColor)
                    Spacer()
                }
                .padding(.horizontal, 16)
                .padding(.top, 8)

                ScrollView {
                    VStack(alignment: .leading, spacing: 16) {

                        // ====== Section Apparence (inchangée sauf libellé pris sur selectedLabel) ======
                        LocalCard(theme: theme) {
                            HStack(spacing: 12) {
                                Image(systemName: "paintpalette.fill")
                                    .font(.title3.weight(.semibold))
                                    .foregroundStyle(theme.accent)

                                VStack(alignment: .leading, spacing: 2) {
                                    Text(selectedLabel)
                                        .font(.headline.weight(.semibold))
                                        .foregroundStyle(theme.foreground)

                                    Text(isPresetFromBundle ? "Thème de l’application" : "Thème enregistré")
                                        .font(.subheadline)
                                        .foregroundStyle(theme.secondary)
                                }
                                Spacer()
                            }
                            .padding(.vertical, 6)
                        }

                        // ====== Pavé : Visualisation (inchangé) ======
                        LocalCard(theme: theme) {
                            HStack(spacing: 12) {
                                VStack(alignment: .leading, spacing: 2) {
                                    Text("Visualisation")
                                        .font(.headline.bold())
                                        .foregroundStyle(theme.foreground)
                                    Spacer()
                                    HStack(alignment: .firstTextBaseline, spacing: 12) {
                                        Text("Bouton Radio")
                                            .font(.subheadline)
                                            .foregroundStyle(theme.secondary)
                                            .lineLimit(1)
                                        Button {
                                            showVisualisation.toggle()
                                        } label: {
                                            Image(systemName: showVisualisation ? "largecircle.fill.circle" : "circle")
                                                .font(.title3)
                                                .foregroundStyle(theme.accent)
                                        }
                                    }
                                }
                                Spacer()
                            }
                            .padding(.vertical, 6)
                        }

                        // ====== Titre “Choix du Thème” (inchangé) ======
                        VStack(alignment: .leading) {
                            Text("Choix du Thème")
                                .font(.title3.weight(.bold))
                                .foregroundStyle(theme.foreground)
                                .padding(.top, 8)
                                .padding(.horizontal, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }

                        // ====== Carte avec la roue (on garde ThemedCard comme chez toi) ======
                        ThemedCard {
                            ThemePickerWheel(
                                items: themeItems,
                                selection: $selectedItem,
                                textColor: themeManager.theme.foreground   // même couleur que tes boutons
                            ) { item in
                                let t = ThemeCatalog.shared.loadTheme(from: item)
                                withAnimation(.easeInOut) {
                                    themeManager.theme = t
                                    themeManager.updateBackgroundColor(t.background)
                                    themeManager.updateHeaderColor(t.headerColor)
                                    themeManager.updatePrimaryTextColor(t.foreground)
                                    // si tu gardes un aperçu local:
                                    theme = LocalTheme.fromTheme(t)
                                    didApply = false
                                }
                            }
                        }

                        // ====== Récap (inchangé, libellés basés sur selectedLabel) ======
                        LocalCard(theme: theme) {
                            HStack(spacing: 12) {
                                VStack(alignment: .leading, spacing: 2) {
                                    Text(selectedLabel)
                                        .font(.headline.weight(.semibold))
                                        .foregroundStyle(theme.foreground)

                                    Text(isPresetFromBundle ? "Thème de l’application" : "Thème enregistré")
                                        .font(.subheadline)
                                        .foregroundStyle(theme.secondary)
                                }
                                .padding(.top, 4)
                                Spacer()
                            }
                        }
                        .buttonStyle(.plain)

                        // ====== Actions (Annuler / Appliquer) (inchangées) ======
                        HStack(spacing: 12) {
                            Button {
                                restoreSnapshot()
                            } label: {
                                ThemedCard(fixedHeight: 56) {
                                    HStack {
                                        Spacer()
                                        Text("Annuler")
                                            .font(.headline.bold())
                                            .foregroundStyle(themeManager.theme.accent)
                                        Spacer()
                                    }
                                }
                            }
                            .buttonStyle(.plain)

                            Button {
                                applyAction()
                            } label: {
                                ThemedCard(fixedHeight: 56) {
                                    HStack {
                                        Spacer()
                                        Text("Apliquer")
                                            .font(.headline.bold())
                                            .foregroundStyle(themeManager.theme.accent)
                                        Spacer()
                                    }
                                }
                            }
                            .buttonStyle(.plain)
                        }
                        .padding(.top, 4)
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 8)
                    .padding(.bottom, 120) // espace pour la bottom bar globale
                }
            }
        }
        // -------- Lifecycle --------
        .onAppear {
            // 1) snapshot d’arrivée
            takeSnapshotOnAppear()

            // 2) charge la liste depuis JSON (bundle + Documents/Themes)
            let items = ThemeCatalog.shared.listThemes()
            // insère “Actuel (ne rien changer)” tout en haut via selectedItem = nil
            self.themeItems = items
            self.selectedItem = nil
        }
        .onDisappear {
            // si on quitte sans “Appliquer”, on restaure l’état d’arrivée
            if !didApply { restoreSnapshot() }
        }
        .navigationBarBackButtonHidden(true)
        .toolbar {
            ToolbarItem(placement: .topBarLeading) {
                Button {
                    if !didApply { restoreSnapshot() }
                    dismiss()
                } label: {
                    HStack(spacing: 6) {
                        Image(systemName: "chevron.left")
                        Text("Retour")
                    }
                    .foregroundStyle(themeManager.theme.accent)
                }
            }
        }
        .onChange(of: selectedItem) { newItem in
            if let it = newItem {
                applySelectedItem(it)
            }
        }
    }
}
// Sous-vue compacte pour la roue de thèmes JSON
private struct ThemePickerWheel: View {
    let items: [ThemeListItem]
    @Binding var selection: ThemeListItem?
    let textColor: Color
    var onChange: (ThemeListItem) -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Picker("Thème", selection: $selection) {
                ForEach(items) { item in
                    Text(item.displayName)
                        .tag(Optional(item)) // IMPORTANT: tag = Optional(ThemeListItem)
                }
            }
            .pickerStyle(.wheel)
            .frame(height: 140)
            .clipped()
        }
        .onChange(of: selection) { newValue in
            if let it = newValue { onChange(it) }
        }
    }
}
#Preview {
    NavigationStack {
        ThemeDefautlView()
            // // // .environmentObject(ThemeManager(default: .aetherionDark))
    }
}
